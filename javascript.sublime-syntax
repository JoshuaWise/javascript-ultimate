%YAML 1.2
---
name: JavaScript Test
file_extensions: [js, htc]
first_line_match: '^#!/usr/bin/env node([{{whitespace}}].*)?(?={{line_terminator_sequence}}|$)'
scope: source.js

variables:
  # Very low-level character categories
  unicode_other_id_start: '\x{2118}\x{212E}\x{309B}\x{309C}'
  unicode_other_id_continue: '\x{1369}\x{00B7}\x{0387}\x{19DA}'
  unicode_id_start: '\p{L}\p{Nl}{{unicode_other_id_start}}'
  unicode_id_continue: '{{unicode_id_start}}\p{Mn}\p{Mc}\p{Nd}\p{Pc}{{unicode_other_id_continue}}'
  ident_start: '{{unicode_id_start}}_$'
  ident_part: '{{unicode_id_continue}}\x{200C}\x{200D}_$'

  # Low-level character categories
  whitespace: '\x{0020}\x{0009}\x{000B}\x{000C}\x{00A0}\x{FEFF}\p{Zs}'
  line_terminator: '\x{000a}\x{000d}\x{2028}\x{2029}'

  # Low-level JavaScript categories
  exp: '([eE][+-]?[0-9]+)?'
  line_terminator_sequence: '(\x{000d}\x{000a}|[{{line_terminator}}])'
  common_regexp_escape_sequences: '({{hex_escape_sequence}}|{{unicode_escape_sequence}}|c[a-zA-Z]|0(?![0-9])|[1-9][0-9]*)'
  common_regexp_operators: (\^|\$|\\|\.|\*|\+|\?|\(|\)|\[|\]|\{|\}|\||\/)

  # High-level JavaScript categories
  keyword: '(break|case|catch|class|const|continue|debugger|default|delete|do|else|export|extends|finally|for|function|if|import|in|instanceof|new|return|super|switch|this|throw|try|typeof|var|void|while|with|yield|let|static)'
  future_reserved_word: '(enum|await|implements|interface|package|private|protected|public)'
  reserved_word: ({{keyword}}|{{future_reserved_word}}|null|true|false)
  hex_escape_sequence: '(x\h{2})'
  unicode_escape_sequence: '(u\h{4}|u\{\h+\})'
  ident: '([{{ident_start}}][{{ident_part}}]*)'
  b_before: '(?<![{{ident_part}}])' # word-break before
  b_after: '(?![{{ident_part}}])' # word-break after
  to_token: '[{{whitespace}}{{line_terminator}}]*+' # skip to next token
  non_token: '[{{whitespace}}{{line_terminator}}]++' # matches non-tokens
  end_of_statement: '(;|{{line_terminator_sequence}})'

contexts:
  main:
    - match: '^#!/usr/bin/env node([{{whitespace}}].*)?(?={{line_terminator_sequence}}|$)'
      scope: comment.line.shebang.js
    - include: statement

  statement:
    - match: '{{non_token}}'
    - include: block_statement
    # - include: import_statement
    # - include: export_statement
    # - include: variable_statement
    # - include: declaration
    - include: simple_control_statement
    - include: do_statement
    - include: for_statement
    - include: switch_statement
    - include: try_statement
    - include: goto_statement
    - include: termination_statement
    - include: debugger_statement
    - include: labelled_statement
    - match: '(?=.)'
      push: expression

  _need_closing_parenthesis:
    - match: '\)'
      pop: true

  _need_closing_square_bracket:
    - match: '\]'
      pop: true

  _need_closing_curly_bracket:
    - match: '\}'
      pop: true

  _need_colon:
    - match: ':'
      pop: true

  _end_of_statement:
    - match: '{{end_of_statement}}'
      pop: true
    - match: '[^{{whitespace}}]'
      scope: invalid.illegal.js

  block_statement:
    - match: '\{'
      push:
        - include: _need_closing_curly_bracket
        - include: statement

  simple_control_statement:
    - match: '{{b_before}}(if|while|with){{b_after}}'
      scope: keyword.control.js
      push:
        - match: '\('
          set: [_need_closing_parenthesis, expression]

  do_statement:
    - match: '{{b_before}}do{{b_after}}'
      scope: keyword.control.js

  for_statement:
    - match: '{{b_before}}for{{b_after}}'
      scope: keyword.control.js
      push:
        - match: '\('
          set: [_for_statement_first_semicolon, expression]

  _for_statement_first_semicolon:
    - match: ';'
      set: [_for_statement_second_semicolon, expression]

  _for_statement_second_semicolon:
    - match: ';'
      set: [_end_of_for_statement, expression]

  _end_of_for_statement:
    - match: '[^){{whitespace}}{{line_terminator}}]'
      scope: invalid.illegal.js
    - include: _need_closing_parenthesis

  switch_statement:
    - match: '{{b_before}}switch{{b_after}}'
      scope: keyword.control.js
      push:
        - match: '\('
          set: [_switch_statement_brackets, expression]

  _switch_statement_brackets:
    - match: '\)'
      set:
        - match: '\{'
          set:
          - match: '{{b_before}}case{{b_after}}'
            scope: keyword.control.js
            push:
              - match: ':'
                scope: invalid.illegal.js
                pop: true
              - match: '{{to_token}}(?=[^:])'
                set: [_need_colon, expression]
          - match: '{{b_before}}default{{b_after}}'
            scope: keyword.control.js
            push:
              - match: '[^:{{whitespace}}{{line_terminator}}]'
                scope: invalid.illegal.js
              - match: ':'
                pop: true
          - include: _need_closing_curly_bracket
          - include: statement

  try_statement:
    - match: '{{b_before}}try{{b_after}}'
      scope: keyword.control.js
      push:
        - match: '\{'
          set:
            - match: '\}'
              set:
                - include: _catch_statement
                - include: _finally_statement
            - include: statement

  _catch_statement:
    - match: '{{b_before}}catch{{b_after}}'
      scope: keyword.control.js
      set:
        - match: '\('
          set:
            # TODO
            # - match: '{{b_before}}{{ident}}{{b_after}}(?!{{to_token}}{{ident}})' # only one ident should be allowed here
            #   scope: variable.language.js
            - match: '\)'
              set:
              - match: '\{'
                set:
                  - match: '\}'
                    set:
                      - include: _finally_statement
                      - match: '{{to_token}}(?!finally($|[^{{ident_part}}]))(?=.)'
                        pop: true
                  - include: statement

  _finally_statement:
    - match: '{{b_before}}finally{{b_after}}'
      scope: keyword.control.js
      set:
        - match: '\{'
          set:
            - include: _need_closing_curly_bracket
            - include: statement

  goto_statement:
    - match: '{{b_before}}(break|continue){{b_after}}'
      scope: keyword.control.js
      push:
        - match: '{{b_before}}{{reserved_word}}{{b_after}}'
          scope: invalid.illegal.js
          set: _end_of_statement
        - match: '{{b_before}}{{ident}}{{b_after}}'
          scope: entity.name.section.js
          set: _end_of_statement
        - include: _end_of_statement

  termination_statement:
    - match: '{{b_before}}(return|throw){{b_after}}'
      scope: keyword.control.js
      push: [_end_of_statement, expression]

  debugger_statement:
    - match: '{{b_before}}debugger{{b_after}}'
      scope: keyword.control.js
      push: _end_of_statement

  labelled_statement: # this doesn't extend through new lines
    - match: '(?={{b_before}}{{reserved_word}}{{to_token}}:)'
      push:
        - match: '({{reserved_word}}){{to_token}}:'
          captures:
            1: invalid.illegal.js
          pop: true
    - match: '(?={{b_before}}{{ident}}{{to_token}}:)'
      push:
        - match: '({{ident}}){{to_token}}:'
          captures:
            1: entity.name.section.js
          pop: true
    - match: ':'
      scope: invalid.illegal.js

  expression:
    - match: '{{non_token}}'
    - include: parenthesized_expression
    - include: string_literal
    - include: template_literal
    - include: regular_expression_literal
    - include: numeric_literal
    # - include: array_literal
    # - include: object_literal
    # - include: function_expression
    # - include: class_expression
    - include: constant_or_variable
    - include: new_keyword
    - include: unary_operators
    # - include: illegal_word
    # - include: identifier_reference
    - match: '(?=.)'
      pop: true

  parenthesized_expression:
    - match: '\('
      push: [secondary_expression, _need_closing_parenthesis, expression]

  string_literal:
    - match: '(''|")(use strict)(\1)'
      scope: string.quoted.js
      captures:
        1: punctuation.definition.string.begin.js
        2: comment.directive.js
        3: punctuation.definition.string.end.js
      set: secondary_expression
    - match: '"'
      scope: punctuation.definition.string.begin.js
      set:
        - meta_include_prototype: false
        - meta_scope: string.quoted.js
        - include: _common_string_escape_sequences
        - match: '{{line_terminator_sequence}}'
          set:
            - meta_include_prototype: false
            - meta_scope: string.quoted.js
            - include: _common_string_escape_sequences
            - match: '"'
              scope: invalid.illegal.js
              set: secondary_expression
        - match: '"'
          scope: punctuation.definition.string.end.js
          set: secondary_expression
    - match: ''''
      scope: punctuation.definition.string.begin.js
      set:
        - meta_include_prototype: false
        - meta_scope: string.quoted.js
        - include: _common_string_escape_sequences
        - match: '{{line_terminator_sequence}}'
          set:
            - meta_include_prototype: false
            - meta_scope: string.quoted.js
            - include: _common_string_escape_sequences
            - match: ''''
              scope: invalid.illegal.js
              set: secondary_expression
        - match: ''''
          scope: punctuation.definition.string.end.js
          set: secondary_expression

  _common_string_escape_sequences:
    - match: '(\\){{line_terminator_sequence}}'
      scope: constant.character.escape.js
      captures:
        1: linecontinuation.js
    - match: '\\(0(?![0-9])|[bfnrtv''"\\]|{{hex_escape_sequence}}|{{unicode_escape_sequence}})'
      scope: constant.character.escape.js
    - match: '\\(0[0-9]+|[1-9][0-9]*)?'
      scope: invalid.illegal.js

  template_literal:
    - match: '`'
      scope: punctuation.definition.string.begin.js
      set: _template_literal_contents

  _template_literal_contents:
    - meta_include_prototype: false
    - meta_scope: string.quoted.template.js
    - match: '\\\$'
      scope: constant.character.escape.js
    - include: _common_string_escape_sequences
    - match: '\$\{'
      scope: variable.language.js
      set: [_template_literal_close_interpolation, expression]
    - match: '`'
      scope: punctuation.definition.string.end.js
      set: secondary_expression

  _template_literal_close_interpolation:
    - match: '\}'
      scope: variable.language.js
      set: _template_literal_contents

  regular_expression_literal:
    - match: '/'
      scope: string.regexp.js punctuation.definition.string.begin.js
      set: _regular_expression_literal_contents

  _regular_expression_literal_contents:
    - meta_include_prototype: false
    - meta_content_scope: string.regexp.js
    - match: '\\([dDsSwWfnrtvbB]|{{common_regexp_escape_sequences}})'
      scope: constant.character.escape.js regexp-operator.js
    - match: '\\{{common_regexp_operators}}'
      scope: constant.character.escape.js
    - match: '\^|\$|\||\?|\*|\+|\.|\{[0-9]+(,[0-9]*)?\}|\((\?\!|\?=|\?:)?|\)'
      scope: regexp-operator.js
    - match: '\\(0[0-9]+)?'
      scope: invalid.illegal.js
    - match: '(\[\^?)-?'
      scope: string.regexp.characterclass.js
      captures:
        1: punctuation.definition.string.begin.js
      set: _regular_expression_literal_class
    - match: '{{line_terminator_sequence}}'
      scope: invalid.illegal.js
      set: secondary_expression
    - match: '/(([gimuy]*?(?''option''[gimuy])[gimuy]*?\k''option'')|[gimuy]*)({{ident}}|\\)?'
      scope: punctuation.definition.string.end.js
      captures:
        2: invalid.illegal.js
        4: invalid.illegal.js
      set: secondary_expression

  _regular_expression_literal_class:
    - meta_include_prototype: false
    - meta_content_scope: string.regexp.js string.regexp.characterclass.js
    - match: '\\([bfnrtv]|{{common_regexp_escape_sequences}})'
      scope: constant.character.escape.js regexp-operator.js
    - match: '\\(-|{{common_regexp_operators}})'
      scope: constant.character.escape.js
    - match: '\\(0[0-9]+|[wWdDsSB]|c[0-9_])?' # "\c[0-9_]" actually does work in the tested implementations, but it's not in the spec
      scope: invalid.illegal.js
    - match: '(?={{line_terminator_sequence}})'
      set: secondary_expression
    - match: '-?(\])'
      captures:
        1: punctuation.definition.string.end.js
      set: _regular_expression_literal_contents
    - match: '-'
      scope: regexp-operator.js

  numeric_literal:
    - match: '{{b_before}}((0|[1-9][0-9]*)(\.[0-9]*)?{{exp}}|\.[0-9]+{{exp}}){{b_after}}'
      scope: constant.numeric.decimal.js
      set: secondary_expression
    - match: '{{b_before}}0[xX]\h+{{b_after}}'
      scope: constant.numeric.hexadecimal.js
      set: secondary_expression
    - match: '{{b_before}}0[bB][01]+{{b_after}}'
      scope: constant.numeric.binary.js
      set: secondary_expression
    - match: '{{b_before}}0[oO][0-7]+{{b_after}}'
      scope: constant.numeric.octal.js
      set: secondary_expression

  constant_or_variable:
    - match: '{{b_before}}(true|false|null|undefined|Infinity|NaN){{b_after}}'
      scope: constant.language.js
      set: secondary_expression
    - match: '{{b_before}}(this|arguments|super){{b_after}}'
      scope: variable.language.js
      set: secondary_expression

  new_keyword:
    - match: '{{b_before}}new{{b_after}}'
      scope: keyword.operator.js
      set:
        - match: '\.'
          scope: keyword.operator.js
          set:
            - match: '{{b_before}}target{{b_after}}'
              scope: support.class.js
              set: secondary_expression
            - match: '{{b_before}}(t|ta|tar|targ|targe){{b_after}}'
              set: secondary_expression
            - match: '{{b_before}}{{ident}}{{b_after}}'
              scope: invalid.illegal.js
              set: secondary_expression
            - match: '[^{{whitespace}}{{line_terminator}}]'
              scope: invalid.illegal.js
              set: secondary_expression
        - include: _class_name_shallow
        - match: '{{to_token}}([^(.{{ident_start}}])'
          captures:
            1: invalid.illegal.js
          set: secondary_expression

  _class_name_shallow:
    - match: '\('
      set: [_class_name_deep, _need_closing_parenthesis, expression]
    - match: '{{b_before}}{{ident}}{{b_after}}'
      scope: support.class.js
      set: _class_name_deep

  _class_name_deep:
    - match: '\.'
      scope: support.class.js
      set:
        - match: '{{b_before}}{{ident}}{{b_after}}'
          scope: support.class.js
          set: _class_name_deep
    - match: '\['
      set: [_class_name_deep, _need_closing_square_bracket, expression]
    - match: '{{to_token}}(?=[^\[(.])'
      set: secondary_expression

  unary_operators:
    - match: '!|--?|\+\+?|{{b_before}}(typeof|void|delete|yield|await){{b_after}}'
      scope: keyword.operator.js

  illegal_word:
    - match: '{{b_before}}{{reserved_word}}{{b_after}}'
      scope: invalid.illegal.js
      set: secondary_expression

  secondary_expression:
    - match: '{{non_token}}'
    # - include: instanceof_keyword
    - match: '(?=.)'
      pop: true
  #   # - include: conditional_expression
  #   - match: '>>>?=?|<<=?|&=|\^=|\|=' # these operators should demand an expression afterwards
  #     scope: bitwise-operator.js
  #   - match: '--|-=|\+\+|\+=|===?|!==?|<=|>=|&&|\|\||\*=|/=|%=' # these operators should demand an expression afterwards
  #     scope: keyword.operator.js
  #   - match: '!|%|\*|/|-|\+|=|<|>|{{b_before}}(in|typeof|void|delete|yield|await){{b_after}}' # these operators should demand an expression afterwards
  #     scope: keyword.operator.js
  #   - match: '&|\^|~|\|' # these operators should demand an expression afterwards
  #     scope: bitwise-operator.js
  #   # - include: identifier_reference
  #   # - include: bracket_reference_expression
  #     #===== help prevent errors =====#
  #   # - match: '\.[{{whitespace}}{{line_terminator}}]*{{ident}}{{b_after}}' # this doesn't extend through new lines
  #   #   scope: text.js
  #   # - match: '\.[{{whitespace}}{{line_terminator}}]*[^{{whitespace}}{{line_terminator}}]+' # this doesn't extend through new lines
  #   #   scope: invalid.illegal.js
  #   - match: '{{b_before}}{{reserved_word}}{{b_after}}'
  #     scope: invalid.illegal.js

  # conditional_expression:
  #   - match: '\?' # these operators should demand an expression beforehand
  #     push:
  #       - include: expression # only one expression should be allowed here
  #       - match: ':' # these operators should demand an expression afterwards
  #         pop: true

  # instanceof_keyword:
  #   - match: '{{b_before}}instanceof{{b_after}}'
  #     scope: keyword.operator.js
  #     set:
  #       - include: _class_name_shallow
  #       - match: '{{to_token}}([^({{ident_start}}])'
  #         captures:
  #           1: invalid.illegal.js
  #         set: secondary_expression
