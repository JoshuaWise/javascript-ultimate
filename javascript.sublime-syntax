%YAML 1.2
---
name: JavaScript Test
file_extensions: [js, htc]
first_line_match: '^#!/usr/bin/env node(?:{{space}}[^{{line_terminator_chars}}]*+)?+(?={{line_terminator}}|$)'
scope: source.js

variables:
  # Low-level character categories
  unicode_other_id_start: '\x{2118}\x{212E}\x{309B}\x{309C}'
  unicode_other_id_continue: '\x{1369}\x{00B7}\x{0387}\x{19DA}'
  unicode_id_start: '\p{L}\p{Nl}{{unicode_other_id_start}}'
  unicode_id_continue: '{{unicode_id_start}}\p{Mn}\p{Mc}\p{Nd}\p{Pc}{{unicode_other_id_continue}}'
  ident_start: '{{unicode_id_start}}_$\\'
  ident_part: '{{unicode_id_continue}}\x{200C}\x{200D}_$\\'
  space_chars: '\x{0020}\x{0009}\x{000B}\x{000C}\x{00A0}\x{FEFF}\p{Zs}'
  line_terminator_chars: '\x{000a}\x{000d}\x{2028}\x{2029}'

  # Low-level JavaScript categories
  operator: '[`~!@#%^&*-=+(){}\[\]\\|;:''"<>?,./]'
  keyword: '(?:break|case|catch|class|const|continue|debugger|default|delete|do|else|export|extends|finally|for|function|if|import|in|instanceof|new|return|super|switch|this|throw|try|typeof|var|void|while|with|yield|let|static)'
  future_reserved_word: '(?:enum|await|implements|interface|package|private|protected|public)'
  hex_escape_sequence: '(?:x\h{2})'
  unicode_escape_sequence: '(?:u\h{4}|u\{\h++\})'
  common_regexp_escape_sequences: '(?:{{hex_escape_sequence}}|{{unicode_escape_sequence}}|c[a-zA-Z]|0(?![0-9])|[1-9][0-9]*+)'
  common_regexp_operators: '(?:\^|\$|\\|\.|\*|\+|\?|\(|\)|\[|\]|\{|\}|\||\/)'

  # Articulatory JavaScript categories
  space: '[{{space_chars}}]'
  line_terminator: '(?:\x{000d}\x{000a}|[{{line_terminator_chars}}])'
  non_token: '[{{space_chars}}{{line_terminator_chars}}]++'
  to_token: '[{{space_chars}}{{line_terminator_chars}}]*+' # skip to next token
  token: '[^{{space_chars}}{{line_terminator_chars}}]'
  b_before: '(?<![{{ident_part}}])' # word-break before
  b_after: '(?![{{ident_part}}])' # word-break after

  # High-level JavaScript categories
  statement_terminator: '(?:;|{{line_terminator}})'
  ident: '(?:{{b_before}}[{{ident_start}}][{{ident_part}}]*+{{b_after}})'
  reserved_word: (?:{{b_before}}(?:{{keyword}}|{{future_reserved_word}}|null|true|false){{b_after}})

contexts:
  prototype:
    - match: '(//)[^{{line_terminator_chars}}]*+{{line_terminator}}?+'
      scope: comment.line.double-slash.js
      captures:
        1: punctuation.definition.comment.js
    - match: '/\*\*(?!/)'
      scope: punctuation.definition.comment.js
      push:
        - meta_scope: comment.block.documentation.js
        - match: '\*/'
          scope: punctuation.definition.comment.js
          pop: true
        - match: '^{{to_token}}\*{{to_token}}(@{{token}}++)'
          captures:
            1: keyword.other.documentation.custom.js
    - match: '/\*'
      scope: punctuation.definition.comment.js
      push:
        - meta_scope: comment.block.js
        - match: '\*/'
          scope: punctuation.definition.comment.js
          pop: true

  main:
    - match: '^#!/usr/bin/env node(?:{{space}}[^{{line_terminator_chars}}]*+)?+(?={{line_terminator}}|$)'
      scope: comment.line.shebang.js
    - match: ''
      set:
      - match: '{{non_token}}'
      - match: ''
        push: statement



  expression_until_parenthesis: [{match: '{{non_token}}'}, {match: '\)', pop: true},
  {match: '', set: [_continue_expression_until_parenthesis, primary_expression]}]
  _continue_expression_until_parenthesis: [{match: '{{non_token}}'}, {match: '\)', pop: true}, {match: '', push: secondary_expression}]

  expression_until_square_bracket: [{match: '{{non_token}}'}, {match: '\]', pop: true},
  {match: '', set: [_continue_expression_until_square_bracket, primary_expression]}]
  _continue_expression_until_square_bracket: [{match: '{{non_token}}'}, {match: '\]', pop: true}, {match: '', push: secondary_expression}]

  expression_until_end_of_template_interpolation: [{match: '{{non_token}}'}, {match: '\}', scope: variable.language.js, pop: true},
  {match: '', set: [_continue_expression_until_end_of_template_interpolation, primary_expression]}]
  _continue_expression_until_end_of_template_interpolation: [{match: '{{non_token}}'}, {match: '\}', scope: variable.language.js, pop: true}, {match: '', push: secondary_expression}]

  expression_until_semicolon: [{match: '{{non_token}}'}, {match: ';', pop: true},
  {match: '', set: [_continue_expression_until_semicolon, primary_expression]}]
  _continue_expression_until_semicolon: [{match: '{{non_token}}'}, {match: ';', pop: true}, {match: '', push: secondary_expression}]

  expression_until_colon: [{match: '{{non_token}}'}, {match: ':', pop: true},
  {match: '', set: [_continue_expression_until_colon, primary_expression]}]
  _continue_expression_until_colon: [{match: '{{non_token}}'}, {match: ':', pop: true}, {match: '', push: secondary_expression}]

  required_expression_until_colon: [{match: '{{non_token}}'}, {match: ':', scope: invalid.illegal.js, pop: true},
  {match: '', set: [_continue_required_expression_until_colon, primary_expression]}]
  _continue_required_expression_until_colon: [{match: '{{non_token}}'}, {match: ':', pop: true}, {match: '', push: secondary_expression}]

  parameter_binding_until_parenthesis: [{match: '{{non_token}}'}, {match: '\)', pop: true},
  {match: '', set: [_continue_parameter_binding_until_parenthesis, parameter_binding]}]
  _continue_parameter_binding_until_parenthesis: [{match: '{{non_token}}'}, {match: '\)', pop: true}, {include: otherwise_invalid}]

  expression_until_end_of_statement: [{match: '{{non_token}}'}, {match: '{{statement_terminator}}', pop: true},
  {match: '', set: [_continue_expression_until_end_of_statement, primary_expression]}]
  _continue_expression_until_end_of_statement: [{match: '{{non_token}}'}, {match: '{{statement_terminator}}', pop: true}, {match: '', push: secondary_expression}]

  end_of_statement: [{match: '{{statement_terminator}}', pop: true}, {include: otherwise_invalid}]
  otherwise_invalid: [{match: '{{token}}', scope: invalid.illegal.js}]

  need_opening_parenthesis: [{match: '\(', pop: true}]
  need_opening_square_bracket: [{match: '\[', pop: true}]
  need_opening_curly_bracket: [{match: '\{', pop: true}]



  statement:
    - match: '{{non_token}}'
    - include: block_statement
    # TODO:
    # - include: import_statement
    # - include: export_statement
    # - include: variable_statement
    # - include: declaration
    - include: if_statement
    - include: with_or_while_statement
    - include: do_statement
    - include: for_statement
    - include: switch_statement
    - include: try_statement
    - include: goto_statement
    - include: termination_statement
    - include: debugger_statement
    - include: labelled_statement
    - match: ''
      set: expression_until_end_of_statement



  block_statement:
    - match: '\{'
      set:
        - match: '{{non_token}}'
        - match: '\}'
          pop: true
        - match: ''
          push: statement

  if_statement:
    - match: '{{b_before}}if{{b_after}}'
      scope: keyword.control.js
      set: [_optional_else_statement, statement, parenthesized_expression]

  _optional_else_statement:
    - match: '{{non_token}}'
    - match: '{{b_before}}else{{b_after}}'
      scope: keyword.control.js
      set: statement
    - match: ''
      pop: true

  with_or_while_statement:
    - match: '{{b_before}}(?:while|with){{b_after}}'
      scope: keyword.control.js
      set: [statement, parenthesized_expression]

  do_statement:
    - match: '{{b_before}}do{{b_after}}'
      scope: keyword.control.js
      set: [_do_while, statement]

  _do_while:
    - match: '{{b_before}}while{{b_after}}'
      set: parenthesized_expression

  for_statement:
    - match: '{{b_before}}for{{b_after}}'
      scope: keyword.control.js
      set: [_for_statement_first_section, need_opening_parenthesis]

  _for_statement_first_section:
    - match: '{{non_token}}'
    - match: '{{b_before}}(?:var|let|const){{b_after}}'
      scope: storage.type.js
      set: [_for_statement_interpret_binding, variable_binding]
    - match: ';'
      set: [statement, expression_until_parenthesis, expression_until_semicolon]
    - match: ''
      set: [_for_statement_interpret_expression, primary_expression]

  _for_statement_interpret_expression:
    - match: '{{non_token}}'
    - match: ';'
      set: [statement, expression_until_parenthesis, expression_until_semicolon]
    - match: '{{b_before}}(?:of|in){{b_after}}'
      set: [statement, expression_until_parenthesis]
    - match: ''
      push: secondary_expression

  _for_statement_interpret_binding:
    - match: ';'
      set: [statement, expression_until_parenthesis, expression_until_semicolon]
    - match: ','
      set: [_for_statement_variable_binding_continuation, variable_binding]
    - match: '{{b_before}}(?:of|in){{b_after}}'
      set: [statement, expression_until_parenthesis]
    - match: '{{b_before}}(?:o|i){{b_after}}'
    - include: otherwise_invalid

  _for_statement_variable_binding_continuation:
    - match: ','
      push: variable_binding
    - match: ';'
      set: [statement, expression_until_parenthesis, expression_until_semicolon]
    - include: otherwise_invalid

  switch_statement:
    - match: '{{b_before}}switch{{b_after}}'
      scope: keyword.control.js
      set: [_switch_statement_block, need_opening_curly_bracket, parenthesized_expression]

  _switch_statement_block:
    - match: '{{non_token}}'
    - match: '\}'
      pop: true
    - match: '{{b_before}}case{{b_after}}'
      scope: keyword.control.js
      push: required_expression_until_colon
    - match: '{{b_before}}default{{b_after}}'
      scope: keyword.control.js
      push:
        - match: ':'
          pop: true
        - include: otherwise_invalid
    - match: ''
      push: statement

  try_statement:
    - match: '{{b_before}}try{{b_after}}'
      scope: keyword.control.js
      set: [_catch_or_finally_statement, block_statement]

  _catch_or_finally_statement:
    - include: _finally_statement
    - match: '{{b_before}}catch{{b_after}}'
      scope: keyword.control.js
      set: [_optional_finally_statement, block_statement, parameter_binding_until_parenthesis, need_opening_parenthesis]

  _optional_finally_statement:
    - match: '{{non_token}}'
    - include: _finally_statement
    - match: ''
      pop: true

  _finally_statement:
    - match: '{{b_before}}finally{{b_after}}'
      scope: keyword.control.js
      set: block_statement

  goto_statement:
    - match: '{{b_before}}(?:break|continue){{b_after}}'
      scope: keyword.control.js
      set:
        - match: '{{reserved_word}}'
          scope: invalid.illegal.js
          set: end_of_statement
        - match: '{{ident}}'
          scope: entity.name.section.js
          set: end_of_statement
        - include: end_of_statement

  termination_statement:
    - match: '{{b_before}}(?:return|throw){{b_after}}'
      scope: keyword.control.js
      set: expression_until_end_of_statement

  debugger_statement:
    - match: '{{b_before}}debugger{{b_after}}'
      scope: keyword.control.js
      set: end_of_statement

  labelled_statement: # this doesn't extend through new lines
    - match: '({{reserved_word}}){{to_token}}:'
      captures:
        1: invalid.illegal.js
      pop: true
    - match: '({{ident}}){{to_token}}:'
      captures:
        1: entity.name.section.js
      pop: true
    - match: ':'
      scope: invalid.illegal.js



  primary_expression:
    - match: '{{non_token}}'
    - include: parenthesized_expression
    - include: string_literal
    - include: template_literal
    - include: regular_expression_literal
    - include: numeric_literal
    # TODO:
    # - include: array_literal
    # - include: object_literal
    # - include: function_expression
    # - include: class_expression
    # - include: arrow_function_expression
    - include: constant_or_variable
    - include: new_keyword
    - include: unary_operators
    - include: reserved_word_reference
    - include: identifier_reference
    - include: invalid_identifier_reference



  parenthesized_expression:
    - match: '\('
      set: expression_until_parenthesis

  string_literal:
    - match: '(''|")(use strict)(\1)'
      scope: string.quoted.js
      captures:
        1: punctuation.definition.string.begin.js
        2: comment.directive.js
        3: punctuation.definition.string.end.js
      pop: true
    - match: ''''
      scope: punctuation.definition.string.begin.js
      set: _string_contents
      with_prototype:
        - match: '"'
    - match: '"'
      scope: punctuation.definition.string.begin.js
      set: _string_contents
      with_prototype:
        - match: ''''

  _string_contents:
    - meta_include_prototype: false
    - meta_scope: string.quoted.js
    - include: _string_escape_sequences
    - match: '{{line_terminator}}'
      set:
        - meta_include_prototype: false
        - meta_scope: string.quoted.js
        - include: _string_escape_sequences
        - match: '[''"]'
          scope: punctuation.definition.string.end.js invalid.illegal.js
          pop: true
    - match: '[''"]'
      scope: punctuation.definition.string.end.js
      pop: true

  _string_escape_sequences:
    - match: '(\\){{line_terminator}}'
      scope: constant.character.escape.js
      captures:
        1: linecontinuation.js
    - match: '\\(?:0(?![0-9])|[bfnrtv''"\\]|{{hex_escape_sequence}}|{{unicode_escape_sequence}})'
      scope: constant.character.escape.js
    - match: '\\(?:0[0-9]++|[1-9][0-9]*+)?+'
      scope: invalid.illegal.js

  template_literal:
    - match: '`'
      scope: punctuation.definition.string.begin.js
      set:
        - meta_include_prototype: false
        - meta_scope: string.quoted.template.js
        - match: '\\\$'
          scope: constant.character.escape.js
        - include: _string_escape_sequences
        - match: '\$\{'
          scope: variable.language.js
          push: expression_until_end_of_template_interpolation
        - match: '`'
          scope: punctuation.definition.string.end.js
          pop: true

  regular_expression_literal:
    - match: '/'
      scope: string.regexp.js punctuation.definition.string.begin.js
      set: _regular_expression_literal_contents

  _regular_expression_literal_contents:
    - meta_include_prototype: false
    - meta_content_scope: string.regexp.js
    - match: '\\(?:[dDsSwWfnrtvbB]|{{common_regexp_escape_sequences}})'
      scope: constant.character.escape.js regexp-operator.js
    - match: '\\{{common_regexp_operators}}'
      scope: constant.character.escape.js
    - match: '\^|\$|\||\?|\*|\+|\.|\{[0-9]++(?:,[0-9]*+)?+\}|\((?:\?\!|\?=|\?:)?+|\)'
      scope: regexp-operator.js
    - match: '\\(?:0[0-9]++)?+'
      scope: invalid.illegal.js
    - match: '(\[\^?+)-?+'
      scope: string.regexp.characterclass.js
      captures:
        1: punctuation.definition.string.begin.js
      set: _regular_expression_literal_class
    - match: '{{line_terminator}}'
      scope: invalid.illegal.js
      pop: true
    - match: '/(?:([gimuy]*?(?''option''[gimuy])[gimuy]*?\k''option'')|[gimuy]*)([{{ident_part}}]*+)'
      scope: punctuation.definition.string.end.js
      captures:
        1: invalid.illegal.js
        3: invalid.illegal.js
      pop: true

  _regular_expression_literal_class:
    - meta_include_prototype: false
    - meta_content_scope: string.regexp.js string.regexp.characterclass.js
    - match: '\\(?:[bfnrtv]|{{common_regexp_escape_sequences}})'
      scope: constant.character.escape.js regexp-operator.js
    - match: '\\(?:-|{{common_regexp_operators}})'
      scope: constant.character.escape.js
    - match: '\\(?:0[0-9]++|[wWdDsSB]|c[0-9_])?+' # "\c[0-9_]" actually does work in the tested implementations, but it's not in the spec
      scope: invalid.illegal.js
    - match: '(?={{line_terminator}})'
      pop: true
    - match: '-?+(\])'
      captures:
        1: punctuation.definition.string.end.js
      set: _regular_expression_literal_contents
    - match: '-'
      scope: regexp-operator.js

  numeric_literal:
    - match: '{{b_before}}(?:(?:0|[1-9][0-9]*+)(?:\.[0-9]++)?+(?:[eE][+-]?+[0-9]++)?+|\.[0-9]++(?:[eE][+-]?+[0-9]++)?+){{b_after}}'
      scope: constant.numeric.decimal.js
      pop: true
    - match: '{{b_before}}(?:0|[1-9][0-9]*+)\.(?:[eE][+-]?+[0-9]++{{b_after}}|([{{ident_part}}]*+))'
      scope: constant.numeric.decimal.js
      captures:
        1: invalid.illegal.js
      pop: true
    - match: '{{b_before}}0[xX]\h++{{b_after}}'
      scope: constant.numeric.hexadecimal.js
      pop: true
    - match: '{{b_before}}0[bB][01]++{{b_after}}'
      scope: constant.numeric.binary.js
      pop: true
    - match: '{{b_before}}0[oO][0-7]++{{b_after}}'
      scope: constant.numeric.octal.js
      pop: true

  constant_or_variable:
    - match: '{{b_before}}(?:true|false|null|undefined|Infinity|NaN){{b_after}}'
      scope: constant.language.js
      pop: true
    - match: '{{b_before}}(?:this|arguments|super){{b_after}}'
      scope: variable.language.js
      pop: true

  new_keyword:
    - match: '{{b_before}}new{{b_after}}'
      scope: keyword.operator.js
      set:
        - match: '{{non_token}}'
        - match: '\.'
          scope: keyword.operator.js
          set:
            - match: '{{b_before}}target{{b_after}}'
              scope: support.class.js
              pop: true
            - match: '{{b_before}}(?:t|ta|tar|targ|targe){{b_after}}'
              pop: true
            - match: '{{ident}}'
              scope: invalid.illegal.js
              pop: true
            - match: '{{token}}++'
              scope: invalid.illegal.js
              pop: true
        - include: _class_name_shallow

  _class_name_shallow:
    - match: '{{non_token}}'
    - match: '\('
      set: [_class_name_deep, expression_until_parenthesis]
    - match: '{{reserved_word}}'
      scope: invalid.illegal.js
      set: _class_name_deep
    - match: '{{ident}}'
      scope: support.class.js
      set: _class_name_deep
    - match: ''
      set: primary_expression

  _class_name_deep:
    - match: '{{non_token}}'
    - match: '\.'
      scope: support.class.js
      push:
        - match: '{{ident}}'
          scope: support.class.js
          pop: true
        - match: '{{token}}'
          scope: invalid.illegal.js
          pop: true
    - match: '\['
      push: expression_until_square_bracket
    - match: ''
      pop: true

  # It's okay not to pop here because unary_operators are only used via the
  # primary_expression context.
  unary_operators:
    - match: '{{b_before}}yield(?:{{to_token}}\*|{{b_after}})'
      scope: keyword.operator.js
      set:
        - match: '{{non_token}}'
        - match: '{{line_terminator}}'
          pop: true
        - include: primary_expression
    - match: '!|--?+|\+\+?+|\.\.\.|{{b_before}}(?:typeof|void|delete|await){{b_after}}'
      scope: keyword.operator.js
      set: primary_expression
    - match: '~'
      scope: bitwise-operator.js
      set: primary_expression

  reserved_word_reference:
    - match: '{{reserved_word}}'
      scope: invalid.illegal.js
      pop: true

  identifier_reference:
    - match: '{{b_before}}(?:Object|Function|Boolean|String|Number|Symbol|Error|EvalError|RangeError|ReferenceError|SyntaxError|TypeError|URIError|Date|RegExp|Array|Uint8Array|Uint8ClampedArray|Int8Array|Uint16Array|Int16Array|Uint32Array|Int32Array|Float32Array|Float64Array|Map|Set|WeakMap|WeakSet|ArrayBuffer|DataView|Promise|Proxy){{b_after}}'
      scope: support.class.js
      pop: true
    - match: '{{b_before}}(?:console|Math|JSON|Reflect|Intl|EPSILON|MAX_SAFE_INTEGER|MIN_SAFE_INTEGER|MAX_VALUE|MIN_VALUE|NEGATIVE_INFINITY|POSITIVE_INFINITY|E|LN10|LOG10E|LOG2E|PI|SQRT1_2|SQRT2|BYTES_PER_ELEMENT){{b_after}}'
      scope: support.constant.js
      pop: true
    - match: '{{b_before}}(?:eval|isFinite|isNaN|parseFloat|parseInt|decodeURI|decodeURIComponent|encodeURI|encodeURIComponent){{b_after}}'
      scope: support.function.js
      pop: true
    - match: '{{ident}}'
      pop: true

  invalid_identifier_reference:
    - match: '{{b_before}}[{{ident_part}}]++{{b_after}}'
      scope: invalid.illegal.js
      pop: true



  secondary_expression:
    - match: '{{non_token}}'
    - include: instanceof_keyword
    - include: binary_operators
    - include: dot_reference
    - include: square_bracket_reference
    - include: function_invocation
    - include: template_literal
    - include: conditional_expression
    - include: otherwise_invalid



  instanceof_keyword:
    - match: '{{b_before}}instanceof{{b_after}}'
      scope: keyword.operator.js
      set: _class_name_shallow

  binary_operators:
    - match: '>>>?+=?+|<<=?+|&=|\^=|\|='
      scope: bitwise-operator.js
      set: primary_expression
    - match: '\*\*|-=|\+=|===?+|!==?+|<=|>=|&&|\|\||\*=?+|/=|%='
      scope: keyword.operator.js
      set: primary_expression
    - match: '\+\+|--'
      scope: keyword.operator.js
      pop: true
    - match: '!|%|\*|/|-|\+|=|<|>|{{b_before}}in{{b_after}}'
      scope: keyword.operator.js
      set: primary_expression
    - match: '&|\^|~|\|'
      scope: bitwise-operator.js
      set: primary_expression
    - match: ','
      set: primary_expression

  dot_reference:
    - match: '\.'
      set:
        - match: '{{b_before}}(?:prototype|length|size|name|message|buffer|byteLength|byteOffset|EPSILON|MAX_SAFE_INTEGER|MIN_SAFE_INTEGER|MAX_VALUE|MIN_VALUE|NEGATIVE_INFINITY|POSITIVE_INFINITY|NaN|E|LN10|LOG10E|LOG2E|PI|SQRT1_2|SQRT2|BYTES_PER_ELEMENT|hasInstance|isConcatSpreadable|iterator|(?:split|replace|search|match)(?!{{to_token}}\()|species|toPrimitive|toStringTag|unscopables){{b_after}}'
          scope: support.constant.js
          pop: true
        - match: '{{b_before}}(?:create|ceil|cos|defineProperty|defineProperties|freeze|fromCharCode|fromCodePoint|chatAt|charCodeAt|codePointAt|concat|endsWith|includes|indexOf|lastIndexOf|localeCompare|match|normalize|repeat|replace|search|slice|split|startsWith|substr|substring|toLocaleLowerCase|toLocaleUpperCase|toLowerCase|toUpperCase|trim|floor|getOwnProperty|getOwnPropertyDescriptor|getOwnPropertyDescriptors|getOwnPropertyName|getOwnPropertySymbols|getPrototypeOf|is|isExtensible|isFrozen|isSealed|isArray|isView|keys|pow|parse|preventExtensions|seal|sin|sqrt|stringify|tan|acos|atan2|atan|asin|abs|exp|log|max|min|random|round|UTC|now|exec|test|toString|toSource|assign|hasOwnProperty|isPrototypeOf|propertyIsEnumerable|toLocaleString|valueOf|setPrototypeOf|values|entries|call|apply|bind|is|isInteger|isFinite|isNaN|isSafeInteger|parseFloat|parseInt|toExponential|toFixed|toPrecision|trunc|tanh|sinh|cosh|sign|log2|log10|log1p|imul|hypot|fround|expml|clz32|cbrt|atanh|asinh|acosh|getDate|getDay|getFullYear|getHours|getMilliseconds|getMinutes|getMonth|getSeconds|getTime|getTimezoneOffset|getUTCDate|getUTCDay|getUTCFullYear|getUTCHours|getUTCMilliseconds|getUTCMinutes|getUTCMonth|getUTCSeconds|setDate|setFullYear|setHours|setMilliseconds|setMinutes|setMonth|setSeconds|setTime|setUTCDate|setUTCFullYear|setUTCHours|setUTCMilliseconds|setUTCMinutes|setUTCMonth|setUTCSeconds|toDateString|toISOString|toJSON|toLocaleDateString|toLocaleTimeString|toTimeString|toUTCString|for|keyFor|from|copyWithin|every|fill|filter|find|findIndex|forEach|join|map|pop|push|shift|unshift|reduce|reduceRight|reverse|some|sort|set|subarray|clear|delete|get|has|add|construct|deleteProperty|getCanonicalLocales|next|return|throw|all|race|then|catch|resolve|reject|getFloat32|setFloat32|getFloat64|setFloat64|getInt16|setInt16|getInt32|setInt32|getInt64|setInt64|getInt8|setInt8|getUint16|setUint16|getUint32|setUint32|getUint64|setUint64|getUint8|setUint8|assert|count|dir|dirxml|group|groupCollapsed|groupEnd|info|log|profile|profileEnd|table|time|timeEnd|trace|warn){{b_after}}'
          scope: support.function.js
          pop: true
        - match: '{{b_before}}constructor{{b_after}}'
          scope: support.class.js
          pop: true
        - match: '{{ident}}'
          pop: true
        - include: invalid_identifier_reference

  square_bracket_reference:
    - match: '\['
      set: expression_until_square_bracket

  conditional_expression:
    - match: '\?'
      set: expression_until_colon

  function_invocation:
    - match: '\('
      set: expression_until_parenthesis



  parameter_binding:

  variable_binding:


